# Rapport Lab 2  - Memory Management

### Réalisé par : 
- Hugo Pauthier
- Vincent Hardouin

## 1 - Shared Memory

1. What could you infer from the output regarding the state of i and *ptr?

Après avoir lancé le programme, nous obtenons ce résultat : 

```shell
dev/ing4/ING4-systemes-d-exploitation on  main [$?⇕] 
❯ ./sharedMemory                         
IPC status from <running system> as of Mon Feb 15 15:05:46 CET 2021
T     ID     KEY        MODE       OWNER    GROUP
Shared Memory:

IPC status from <running system> as of Mon Feb 15 15:05:46 CET 2021
T     ID     KEY        MODE       OWNER    GROUP
Shared Memory:
m  65536 0x000011d7 --rw-rw---- vincenthardouin    staff

Value of *ptr = 55
Value of i = 55
Value of *ptr = 55
Value of i = 54
```

Nous pouvons constater que la valeur `*ptr` a l'air d'être partagé entre le processus parent et enfant. Tandis que, la valeur de `i` ne l'est pas. 

2. Read the code carefully and add your comments to all the lines

```c
int main(int argc, char **argv) {
    int id;
    int i;
    int *ptr;
    system("ipcs -m"); 
    // La méthode system permet de lancer une commande 
    // La commande ipcs Permet de voir les informations à propos des ressources partagées entre les processus.
    // IPC - Inter-Process Communication
    // L'option -m : permet d'afficher seulement les segments partagés et actifs 
    id = shmget(KEY, sizeof(int), IPC_CREAT | PERMS); // Alloue un espace mémoire partagé et retourne l'id de cette espace
    system("ipcs -m");

    ptr = (int *) shmat(id, NULL, 0); // Créer un lien entre l'espace alloué et le processus appelant. NULL : signifie qu'il n'a pas d'adresse d'alloué et donc la méthode en choisit une. 
    *ptr = 54; // On donne une valeur au pointeur ptr
    i = 54;

    if (fork() == 0) {
        (*ptr)++; // On incrémente le pointeur de la variable ptr
        i++; // On incrémente la variable i
        printf("Value of *ptr = %d\nValue of i = %d\n", *ptr, i);
        exit(0); // Permet de finir le processus avec le status 0 => Pas d'erreur. 
    } else {
        wait(NULL); // Permet d'attendre la fin d'exécution du processus fils
        printf("Value of *ptr = %d\nValue of i = %d\n", *ptr, i);
        shmctl(id, IPC_RMID, NULL); // La fonction shmctl permet de contrôler les segments de mémoire partagés. Le paramètre IPC_RMID indique qu'on souhaite détruire le segment identifié par id.
    }
}    
```

## 2 - Parallel Computing 

Nous souhaitons faire un calcul en utilisant plusieurs processus fils pour calculer des sous parties.

Pour ça dans un premier temps nous créons 3 espaces mémoires partagés, qu'on relie à notre programme : 

```c
id1 = shmget(KEY1, sizeof(int), IPC_CREAT | PERMS); 
id2 = shmget(KEY2, sizeof(int), IPC_CREAT | PERMS); 
id3 = shmget(KEY3, sizeof(int), IPC_CREAT | PERMS); 

ptr1 = (int *) shmat(id1, NULL, 0); 
ptr2 = (int *) shmat(id2, NULL, 0); 
ptr3 = (int *) shmat(id3, NULL, 0); 
```

Ensuite, pour traiter chaque sous-partie, nous créons une méthode qui va prendre 3 paramètres, les 2 nombres à ajouter et un pointeur vers un espace mémoire partagée.
La méthode `calculInChildProcess` va :
- Créer un processus fils à l'aide d'un `fork`
- Faire le calcul et stocker le résultat dans le pointeur 
- Terminer le processus avec `exit(0)`, le 0 permet de dire que tout c'est bien passé. 
- Dans le processus principal nous lancons un `wait(NULL)`, pour que le processus principal attende la fin du processus enfant.

```c
void calculInChildProcess(int num1, int num2, int *ptr) {
    if (fork() == 0) {
        (*ptr) = num1 + num2;
        exit(0);
    }
    wait(NULL);
}
```


