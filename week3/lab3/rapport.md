# Rapport Lab 3 - Advanced IO

### Réalisé par : 
- Hugo Pauthier
- Vincent Hardouin

## 1. File Descriptors

### 1. What happens when you run `cat text1 > text2` ? 

La commande `cat` permet d'afficher dans la sortie standard le contenu du fichier passer en paramètre. 

L'opérateur `>` permet de rediriger la sortie vers une autre. 

Dans notre cas, nous redirigeons la sortie de la commande `cat` donc le contenu du fichier `text1` dans le fichier `text2`.

### Lire et écrire dans un fichier. 

On récupère le `file descriptor` du fichier `text1` en READ ONLY
```c
int fd = open("text1", O_RDONLY);
```

On récupère le `file descriptor` du fichier `text2` en WRITE ONLY
```c
int fd2 = open("text2", O_WRONLY);
```

On remplace la sortie standard par `fd2`, ainsi la sortie se fera dans le fichier `text2`
```c
dup2(fd2, STDOUT_FILENO);
```

On boucle le fichier `text1` et on écrit chaque octet dans `text2`
```c
char c; 
while(read(fd, &c, 1)) {
    write(STDOUT_FILENO, &c, 1);
}
```

Ainsi, l'ensemble du contenu de `text1` sera écrit dans `text2`

## 2. Pipes

`ps aux | more`

Le pipe `|` permet de rédiriger la sortie de la commande à sa gauche dans l'entrée de la commande de droite. 

### 1. What kind of interaction is there between these two functions (ps andmore) ?

Dans le cas de cette commande : `ps aux | more`. 
Comme `ps aux` permet d'afficher tous les processus en cours et que cela peut-être énormément long, alors on redirige la sortie de la commande dans l'entrée de la commande `more` qui permet de d'afficher le résultat de manière à pouvoir naviguer dedans.  


### Explication du programme fournie : 

1. Vérifie les préconditions
```c
if (argc != 2) {
    fprintf(stderr, "Usage: %s <string>\n", argv[0]);
    exit(EXIT_FAILURE);
}
```

Ce bout de code permet de vérifier qu'un argument a bien été fourni au programme, sinon ce dernier affiche l'usage et s'arrête avec un code d'erreur. 

2. Création du pipe
```c
if (pipe(pipefd) == -1) {
    perror("pipe");
    exit(EXIT_FAILURE);
}
```
Ici, le bout de code créer un pipe et si la création ne fonctionne pas on gère l'erreur en définissant le message d'erreur et le code d'erreur.

3. Création d'un processus enfant 
```c
cpid = fork();

if (cpid == -1) {
    perror("fork");
    exit(EXIT_FAILURE);
}
```

Ici, le programme créé un fork et gère le cas où il n'y arrive pas. 

4. Description du processus parent

```c
close(pipefd[0]); /* Close unused read end */
write(pipefd[1], argv[1], strlen(argv[1]));
close(pipefd[1]); /* Reader will see EOF */
wait(NULL); /* Wait for child */
exit(EXIT_SUCCESS);
```

Le processus parent : 
- Ferme la sortie d'écoute du pipe
- Ecrit dans le pipe ce que le programme a reçu en argument (la chaine de caractère).
- Il attend que son processus enfant ait fini
- Puis termine avec un code de succès (0). 


5. Description du processus enfant
```c
close(pipefd[1]); /* Close unused write end */
while (read(pipefd[0], &buf, 1) > 0) 
    write(STDOUT_FILENO, &buf, 1);

write(STDOUT_FILENO, "\n", 1);
close(pipefd[0]);
_exit(EXIT_SUCCESS);
```

Le processus enfant : 
- Ferme la sortie d'écriture du pipe
- Boucle sur la lecture du pipe et l'écrit dans la sortie standard
- Puis une fois la lecture finie : 
    - Il coupe la lecture du pipe
    - Termine le processus avec le code de succès (0). 

6. Explication plus globale du programme 

Le programme prend en entrée une chaine de caractère.
Le processus parent : créer un processus enfant et écrit dans un pipe la chaine entrée
Le processus enfant : écoute le pipe et écrit ce qui en sort dans la sortie standard. 


