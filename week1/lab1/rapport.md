# Rapport Lab 1

### Réalisé par : 
- Hugo Pauthier
- Vincent Hardouin


## 1 - Compiling under Linux 

Fait  : 
- Créer un fichier `hello.c`
- Copier le contenu : 
```c
#include <stdio.h>
int main() {
    printf("Hello World!");
}

```
- Lancer la commande pour compiler le programme : 
```shell
gcc -o myHelloProgram hello.c
```

- Lancer le programme : 
```shell
./myHelloProgram
```

3. Lancer la compilation avec cette commande : 
```shell
gcc -g -o myHelloProgram hello.c
```
L'option `-g` permet d'ajouter des informations de debuggage. 

4. 
```shell 
gdb myHelloProgram
```

Ayant un mac nous avons du lancer la commande en super user (`sudo`) pour des problèmes de signature du code. 

Ensuite, nous avons lancé le programme en debug et avons choisi de stopper le programme ligne 3 en ajoutant un point d'arrêt : `break 3`

Voici ce que nous avons obtenu : 

```shell
Reading symbols from /Users/vincenthardouin/dev/ing4/ING4-systemes-d-exploitation/week1/lab1/myHelloProgram.dSYM/Contents/Resources/DWARF/myHelloProgram...
(gdb) list
1       #include <stdio.h>
2       int main() {
3           printf("Hello World!");
4       }
(gdb) break 3
Breakpoint 1 at 0x100003f68: file hello.c, line 3.
(gdb) run arglist
Starting program: /Users/vincenthardouin/dev/ing4/ING4-systemes-d-exploitation/week1/lab1/myHelloProgram arglist
[New Thread 0x2203 of process 68717]
[New Thread 0x1f03 of process 68717]

Thread 2 hit Breakpoint 1, main () at hello.c:3
3           printf("Hello World!");
```

## 2 - Creating and Running a Process (1) - fork 

### Definition

Le fork créé un nouveau processus en dupliquant le processus appelé. Le nouveau processus a un nouveau PID et son PPID réfère à celui du processus appelé. Les deux processus évolue dans des espaces mémoire différent.

### 3 - Small program to show different message for each process

#### Code 
```c
#include <stdio.h>
#include <unistd.h>

int main() {
    if (fork() == 0) {
        printf("Hey ! Je suis le processus fils. PID : %d \n", getpid());
    } else {
        printf("Hey ! Je suis le processus parent. PID : %d \n", getpid());
    }
}
```

#### Résultat 
Ce programme une fois compilé et lancé nous donne : 

```shell
ING4-systemes-d-exploitation/week1/lab1 on  main [!?] 
❯ ./part2fork                  
Hey ! Je suis le processus parent. PID : 69397 
Hey ! Je suis le processus fils. PID : 69398 
```

#### Commentaire  
Nous voyons bien que la fonction fork a créé un nouveau processus comme ces derniers n'ont pas le même pid. 

### 4 - Data share 

Avec l'exemple donné nous avons obtenu : 

```shell
❯ ./part2forkb                 
Hey ! Je suis le processus fils. PID : 69771 
Hey ! Je suis le processus parent. PID : 69770 
5
```

Ce qui permet de voir que les données ne sont pas partagées car sinon nous aurions du obtenir 6 à la dernière ligne. 

### 5 - Create more than one process

Nous avons créé le programme suivant :

```c
#include <stdio.h>
#include <unistd.h>


void create_fork() {
    if(fork() == 0) {
        printf("Hey ! Je suis le processus fils de PPID : %d et mon PID est : %d \n", getppid(), getpid());
    } 
}

int main() {
    if (fork() == 0) {
        printf("Hey ! Je suis le processus fils de PPID : %d et mon PID est : %d \n", getppid(), getpid());
        create_fork();
    } else { 
        printf("Hey ! Je suis le processus parent. PID : %d \n", getpid()); 
        create_fork();
        
    }
    sleep(2);
}
```

Celui-ci permet de créer un processus fils qui lui même créé un processus fils. Et d'autre part le processus parent lui créé un second processus fils. 

```shell
❯ ./part2forkc                   
Hey ! Je suis le processus parent. PID : 70557 
Hey ! Je suis le processus fils de PPID : 70557 et mon PID est : 70560 
Hey ! Je suis le processus fils de PPID : 70557 et mon PID est : 70561 
Hey ! Je suis le processus fils de PPID : 70560 et mon PID est : 70562 
```

#### Commentaire 

Nous voyons bien que le processus Parent (PID : 70557) a créé 2 processus (PID : 70560, 70561). 
Et que le premier processus enfant (PID : 70560) en a créé 1 (PID : 70562)

## 3 - Creating and Running a Process (2) - exec 


### 3 - Run Exec
Pour ouvrir une application sous mac à l'aide d'une commande nous pouvons faire : `open -a appName`.

Du coup dans un programme C, nous pouvons faire un exec avec la même commande : 

```c
#include <unistd.h>

int main() {
    execlp("open", "open", "-a", "firefox", (char *) NULL);
}
```

Le `(char * NULL)` permet de dire qu'on a plus d'arguments à ajouter à notre commande. 

### 4 - What happens after exec 

Comme le exec remplace le processus actuel alors la suite du programme n'est pas lu nous avons donc pas l'affichage de la valeur de i. 

### Fork vs Exec

La fonction `fork` créé un processus copié du processus parent, mais à son propre code de retour. 
Tandis que, `exec` remplace le processus actuel par un nouveau programme. 